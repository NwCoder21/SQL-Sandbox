# One to Many Joins

So far, we have covered data which is basically within one table at a time. The data has been kind of self-contained and no data has been related. But of course, in the real world, all of our data or almost all of it, is related.

For example, we don't have books on a website without also having things like reviews, customers and shopping carts.

Or we might have cars in our database, but then we might have salesmen and dealerships and all of the other things that go along with it.

---

Now we will start to work with multiple tables that are connected.

So we're going to talk about how data is related and then how to implement those relations using multiple tables and some of the buzzwords, some of the big things 
we're talking about here are joints, foreign keys and primary keys, one to one, one to many, many to many relationships etc.

---

<!-- L 219 - Data is Messy --> 

# Data is Messy

this is a section all about relationships and also something called joints, which we'll get to in the second part of this section.

Real world data, unlike what we've been working with, is really messy typically and interrelated. There's a lot of connections between data.

---

So we're going to focus on how we work with interconnected data in the next couple of sections. So we're no longer focusing on one table. We're going to see how do we work with two tables or three or four that are related.

So not just tables that exist independently, but tables that reference one another and are interconnected.

---

![image](https://user-images.githubusercontent.com/107522496/211056789-c0ac1e72-6f6e-46fd-96eb-fe41661dd22d.png)

If we think back to our books table, if we had a bookshop in real life, we would need to do things such as keep track of versions for each book. For example, UK version and US version, hardback and paperback, coloured or black and white version. 

How do you keep track of that? Is that a different table or do you just make a separate book for every one of those? But if you do that, then how do you make sure that they're connected?

![image](https://user-images.githubusercontent.com/107522496/211059127-3f55ae38-5d58-4743-9d03-73eccd223a3a.png)

---

Then we have authors. Well, that might seem straightforward. We have an author, first name and last name, two columns on our books table, but that's not sufficient when we have multiple authors. Some books have multiple authors. What about if it's a research paper that we're selling or a journal that has dozens of authors potentially? So there's a lot of things to keep track of there that we can't really do right now. We only have room for one author in our columns.

---


Then a whole big thing is customers. If we're doing a shop online, books on their own is great, but we also need ways to keep track of customers. So, customers on their own also can't do that much, but we might keep track of their email log in information. Of course, we wouldn't just store their password directly, but for simplicity's sake, let's say we're keeping track of password and email so that they can log in.

---

Orders.

So if customers want to order books, how do we store that? We need to create a new order and it needs to be associated with a customer who created it. It needs to have address information. Maybe it needs to have the contents of the order. Are there books? One book? How do we support that? How do we handle that? What about if we're working with dates and times and we need to keep track of when a return period expires? So we need to have a an order date and then keep track of 30 days or 60 days after that or whatever it is. Then we also need to store or somehow keep track of the transaction information addresses for billing address, not only shipping address, the type of shipping, the billing information. There's so much to store.


---

And then a whole other thing is reviews. So if we go on Amazon or pretty much any book site, any book that you look at will have dozens or hundreds, sometimes thousands of reviews. So we've got reviews, their ratings, that's the number of stars. But then also a title for the review and then a caption and then the actual content of the review, which may be ten characters. I hate this book, however many characters that is. Or it could be a giant paragraph, someone's love letter that they're writing to a book. So how do we account for all of that?

---

And then the last thing that we'll talk about are genres. We could just have one genre. But many books don't cleanly fit into one genre. We might have a vampire novel that's also historical fiction because it's set in Victorian period. England Or we might have a sci fi book that has elements of fantasy or who knows, you can have all sorts of cross-pollinated genres, so only assigning one genre might not be that useful. We may want to have a bunch more. And in fact, on Amazon you can see there are books that will have two or three different genres or different tags associated with them.

---

So what I'm trying to show you here is that we were working with books on their own, but in a typical app or a typical website that has to do with books and a bookstore, in our case, there's a lot more that goes along with books to make anything functional, to store any important information. And this is, I don't know, maybe half of the tables that you would need to get away with kind of the the MVP or the bare minimum.

---

Something like orders, for instance, might actually need to be split into a couple of tables. We might need to have an address section or an address table. We might need to then have a separate billing table. We might need to have shipping. There could be all different tables that we could split it up into.

---

<!-- L220. Relationships Basics -->

# Relationships Basics

Moving on, how do we try to understand how we represent complex data using MySQL?  The answer is we're going to start by talking about the relationship basics.

This is about the different ways that data can be related. For example, if we have two tables, such as orders and customers, students and courses, or movies and reviews, how are these two tables related.

---

There's three main types of relationships:

* One to One Relationship 
* One to Many Relationship
* Many to Many Relationship

---

One to One Relationships are not that common. 

For example, we have two tables. One contains the main details for a customer, such as name, address and email address and the second contains more in-depth details on each customer, such as age, gender, hobbies, dislikes etc. customer_one has their own row, one row in the customer details table and one row in the customer in_depth table. Each row is associated with one customer. This means there's no other customer that could be associated with the customer_one's row because it's a 1 to 1 relationship.

However, One to One Relationship is not that common.

---

Most common is actually a One to Many Relationships. 

![image](https://user-images.githubusercontent.com/107522496/211340197-ae697ae5-a9d0-4e4a-afc1-8c077bc7d4ae.png)

Here's an example, the relationship between books and reviews. One book can have thousands of reviews. But each review in the Reviews table belong to only one specific book. 

So, the relationship is books have many reviews, but reviews belong to one book. So, it's a one to many relationship.

This means the Reviews to Books relationship is One and the Books to Reviews relationship is Many. 

---

![image](https://user-images.githubusercontent.com/107522496/211344496-63babec8-79b7-4bff-aad5-7c0a0836a697.png)

Many to Many Relationships are still fairly common. The way this works is, we have, for example, tow entities, Books and Authors. The way we say it is that a book can have many authors, for example, two authors could write a book together. And those authors can have many books.

So, this is an example of a Many to Many Relationship.

---

# One to Many Relationship

We will be mainly covering One to Many as this is the most common and essential type.

---

![image](https://user-images.githubusercontent.com/107522496/211348640-b8d0a176-321c-4747-a3ad-7b6895cac21c.png)

Let's start with a classic example, Customers and Orders tables. This will be a One to Many Relationship. For example, we have a customer called Joe Harris. Joe can make many orders as he likes, but each order in the table will only belong to one customer. There is no way to have two people associated with one order.

So, it's a one to many. Customers have many orders, but orders have one customer associated with them.

---

![image](https://user-images.githubusercontent.com/107522496/211349549-d54a2806-727e-4e6d-8d92-ca030bda44aa.png)

In our example of Customers and Orders tables, let's look at the basic types of data we might want to store. For Customers table, we would need first and last name, customer's email. 

In a more complex table, we could store registration date, last login date, phone number etc. 

In the Orders table, we would have date of purchase and price of order. 

The first three would be VARCHAR, date would be DATA type, and price would be decimal.

---

The next question is how do we store that, in other words, how do we represent this?

![image](https://user-images.githubusercontent.com/107522496/211351522-5cd1301a-959a-420d-9311-09ed02f32a81.png)

Technically, we could use one table but it would cause issues. For example, there is a lot of duplicated data.

Another issue is that David Bowie and Blue Steele have got customer details on them, but because they have not placed an order yet, there is no value in for the `order_date` and `amount`.

---

So, it's much better to keep our data separated because if we ever need to work with just customers on their own, which happens, there are times on a site where you don't care about orders, you just care about customers.

So, doing it this way is a bad idea. So, what do we do?

---

![image](https://user-images.githubusercontent.com/107522496/211353760-94f9d4b2-ebca-4cd4-993c-94dcce0568e5.png)

Here is the simplest approach. This is how we express a one to many relationship.

We have two tables, Customers and Orders. Each has its own fields. But most importantly ...

![image](https://user-images.githubusercontent.com/107522496/211355660-290c16de-d291-439c-a3fa-749d5b4f54c0.png)

The Orders table has a customer_id (does not matter what it is called) which is a reference to the customer_id field in the Customers table. 

So, whatever customer_id is in a given order (order table), it is going to correspond to an actual customer (customer_id in the Customers table) who placed it.

Continue From 6:49

---

![image](https://user-images.githubusercontent.com/107522496/211512661-546f44ee-e840-4aa8-a750-6bb03a89e4e8.png)

Here is an example. We split up the data which was presented earlier, i.e., the above is the split up version of the table below: 

![image](https://user-images.githubusercontent.com/107522496/211512941-d476322e-0362-47e1-a87d-c605bdc65191.png)

---

In the split up version, in the Customers table we have a customer_id column and in the Orders table we have a customer_id column. The customer_id column in the Orders table tells us which customer has placed the order by pointing towards the Customers table's customer_id column.

As David Bowie and Blue Steele have not bought anything, we don't have data for them in the Orders table. This means there is no extra or NULL data for them. So, we are not storing anythin we don't need.

---

So this is the classic way of structuring a one to many relationship. There are two main terms that need to be discussed.

---

# Primary Key 

![image](https://user-images.githubusercontent.com/107522496/211514200-0836ffb6-65f0-4ad1-85b0-ea6ee12c7277.png)

What a primary key means is that some particular column, in our case the customer_id column, is always unique. This means we only have one row which has a customer_id of 1, 2, 3, etc. 

This is important because if we reference it in another table, as in our case the Orders table, if there are two different customers that have ID of one, then it is useless because which one does it refer to? So it has to be unique.

That's why we can use Auto Increment as it will make sure whenever a new row is being inserted, that it is unique. This ensures no two rows have the same ID.

Then we have the column order_id in the Orders table which is also a primary key which means that each order is unique. 

 ---

# Foreign Key

![image](https://user-images.githubusercontent.com/107522496/211522634-1bcde6de-49f0-4d83-ad9d-d4eedec5f9e8.png)

Foreign Keys are references to another table from within another given table. In our example, the customer_id in the Orders table is referencing the customer_id in the Customers table. 

This means the Customers table does not have a foreign key as it is not referring to another table, but the orders has a primary and foreign key.

We will discuss how to define a foreign key in the schema later on as this is important. For example,  if we try to reference a row which does not exist in another table, we would want it to let us know so we can fix it.

For example, if we tried to insert an customer_id of 20 in the Orders table but there is no customer_id of 20 in the Customers table, we would want it to cause an error and make us aware. This is why we would define the foreign key in the schema.

Otherwise, if we don't say that it's a foreign key explicitly, we could have customer IDs all over the place that don't actually exist.

---

<!-- L 222 - Working with FOREIGN KEY -->

# Working with FOREIGN KEY

![image](https://user-images.githubusercontent.com/107522496/211524843-9c6e5106-30ec-40d7-b6d7-42d3b6992251.png)

Now, try and define these tables. Let's start with customers.

We have customer_id which will be a primary key, auto increment and it will be an integer.

![image](https://user-images.githubusercontent.com/107522496/211526018-8468d5b3-0c4f-49b7-a0fa-602e3de35a1c.png)

---

And now let's create the Orders table: 

![image](https://user-images.githubusercontent.com/107522496/211530704-66117a2c-29d0-4636-a1c8-6c4c970e376a.png)

When setting up the customer_id column in the Orders table, we need to make it clear that this column is associated with the customer's table. 

`INT`: we have used the same data type as id is in the customers table.  

---

This is what it will look like all put together. 

![image](https://user-images.githubusercontent.com/107522496/211531073-d046285d-78e8-423a-a047-4a2663ec4998.png)


```sql
CREATE DATABASE shop;

CREATE TABLE customers (
id INT PRIMARY KEY AUTO_INCREMENT,
first_name VARCHAR (50),
last_name VARCHAR (50),
email VARCHAR (50)
);

CREATE TABLE orders (
id INT PRIMARY KEY AUTO_INCREMENT,
order_date DATE,
amount DECIMAL (8,2),
customer_id INT,
);

INSERT INTO customers (first_name,last_name,email)
VALUES ('Boy', 'George','george@gmail.com'),
	   ('David', 'Bowie','david@gmail.com'),
	   ('George', 'Michael','gm@gmail.com'),
	   ('Blue', 'Steel','blue@gmail.com'),
	   ('Bette', 'Davis','bette@aol.com');

INSERT INTO orders (order_date,amount,customer_id)
VALUES ('2016-02-10', 99.99, 1),
	   ('2017-11-11', 35.50, 1),
	   ('2014-12-12', 800.67, 2),
	   ('2015-01-03', 12.50, 2),
	   ('1999-04-11', 450.25, 5);

```

---

![image](https://user-images.githubusercontent.com/107522496/211531374-bf7d5939-4574-4ebd-958a-e154e0ab1d62.png)

When we run `SELECT * FROM orders;` this is what we get. The customer_id is meant to be referencing an actual customer_id in the Customers table. However, if we insert a row into orders which does not refer back to an customer_id in the Customers table, at the moment, it still will run. For example, 

![image](https://user-images.githubusercontent.com/107522496/211532129-5282d1dd-a5c5-459e-bad3-fd044711c267.png)

Here, we have entered a row with the customer_id equal to 525 in the Orders table, however, there is no customer_id of 525 in the Customers table. 

We don't want this to happen. 

We want to enforce a rule that if we have a foreign key in the orders table called customer_id that is supposed to be linked to a real customer in the customer's table, why don't we set up a rule or a constraint that says that the foreign key (customer_id in the Orders table), has to be a real ID in the Customers table.

---

The way we do this is by using the Foreign Key constraint. 

Now, when we set up a foreign key constraint, it doesn't have to be unique, but it does have to reference a real ID in the other table.

---

![image](https://user-images.githubusercontent.com/107522496/211533506-6fe1fbb7-1d02-4ada-bc16-a882af56de04.png)

This is how we do it. `FOREIGN KEY (customer_id) REFERENCES customers(id)`. The first customer_id is referring to the customer_id within the same table, in this case, the orders table. 

`REFERENCES customers(id)`: is referring to the id column in the customers table. 

---

![image](https://user-images.githubusercontent.com/107522496/211533867-ec2a3d86-ab14-465e-9557-eaee1ca712fd.png)

Essentially, this is what we have done. We have linked both of these columns together to ensure that we can enter a number for customer_id in the orders table which does not exist in the Customers table.  

---

![image](https://user-images.githubusercontent.com/107522496/211537463-c902c760-5023-48fc-b3f0-806f9763ec0c.png)

```sql
CREATE TABLE customers (
id INT PRIMARY KEY AUTO_INCREMENT,
first_name VARCHAR (50),
last_name VARCHAR (50),
email VARCHAR (50)
);

CREATE TABLE orders (
id INT PRIMARY KEY AUTO_INCREMENT,
order_date DATE,
amount DECIMAL (8,2),
customer_id INT,
FOREIGN KEY (customer_id) REFERENCES customers(id)
);

INSERT INTO customers (first_name,last_name,email)
VALUES ('Boy', 'George','george@gmail.com'),
	   ('George', 'Michael','gm@gmail.com'),
       ('David', 'Bowie','david@gmail.com'),
	   ('Blue', 'Steel','blue@gmail.com'),
	   ('Bette', 'Davis','bette@aol.com');

INSERT INTO orders (order_date,amount,customer_id)
VALUES ('2016-02-10', 99.99, 1),
	   ('2017-11-11', 35.50, 1),
	   ('2014-12-12', 800.67, 2),
	   ('2015-01-03', 12.50, 2),
	   ('1999-04-11', 450.25, 5);

```

---

![image](https://user-images.githubusercontent.com/107522496/211537701-c5fb4038-9569-4e4b-9e1b-5ba3cfda81fa.png)

This is what we currently have in the orders table. 

Let's try and add a customer_id in the orders table which does not exist in the customers table ...

![image](https://user-images.githubusercontent.com/107522496/211537977-6119d371-001d-4554-b097-e6b7604e8a29.png)

Now we see an error occurs as it says a foreign key constraint fails which means the customer-id we have tried to enter is not a real customer_id.

---

![image](https://user-images.githubusercontent.com/107522496/211539139-d21ca93c-3fe0-487e-b904-358e3d536e1b.png)

Now, because the customer_id of 3 does exist, David Bowie, it allows us to input this data into the orders table. 

![image](https://user-images.githubusercontent.com/107522496/211539683-3c18dce2-a9e2-4eec-a28a-9cad6b9e7c5b.png)

---

Now that we have a relationship setup, this One to Many Relationship where every customer can have many orders, but each order belongs to one customer, How do we do some basic operations and how do we combine the two? Or, for example, how write a query which tells us who ordered what order_id or how much each customer has spent?

How do we work with these separate tables and join them together? This is what we will cover next.

---

<!-- L224 - Cross Joins -->

# Cross Joins

Now that we have both tables set up, let's try and retrieve information from both of them.

---

![image](https://user-images.githubusercontent.com/107522496/211570009-ebbd092e-19e3-42d2-87f2-1afac2710e54.png)


Let's try and write a query which selects all the orders placed by Boy George.

---

The first way is the long method, where we find his id first from the customers table and then search for that id in the orders table. 

![image](https://user-images.githubusercontent.com/107522496/211571356-714d2084-7850-4ca3-9dec-d8e84f881fb1.png)

Now we have found Boy George's id number. 

---

![image](https://user-images.githubusercontent.com/107522496/211571713-efab4074-c99b-43e8-b96d-5b8d1f57527e.png)

And then we search in the orders table for where the customer_id is 1. We can now see Boy George's orders. 

We can then perform functions on these results such as sum or average etc.

---

Another long way would be to use a sub-query, such as;

![image](https://user-images.githubusercontent.com/107522496/211572808-a637ada7-177d-47a6-bc7e-4113f018c669.png)

Here, the `(SELECT id FROM customers WHERE last_name = 'George')` will evaluate to a number, and will then look like:

![image](https://user-images.githubusercontent.com/107522496/211573107-fd6e1462-e07c-4c83-be65-18fbea5f31c7.png)

The results will look like:

![image](https://user-images.githubusercontent.com/107522496/211573487-ca1b9e0f-ef32-4553-957f-e5aeac640252.png)

But we're still not seeing any information from the customers table alongside the information from the orders table.

We have to know that customer_id here (in the orders table), one belongs to Boy George.

So, it would be helpful if we could join information from both tables together. 

---

So, let's say we wanted to see every single customer next to their orders? For example, what if we wanted to see `date`, `amount`, and `first_name` together. 

We can use a _CROSS JOIN_.

---

![image](https://user-images.githubusercontent.com/107522496/211574391-ebb5addb-af92-49be-bf5f-c690cc4779ae.png)

CROSS JOIN will take every single row from customers and combine it with every single row from orders. Which means we will get every combination possible. There's no logic really at all.

Currently, this is how our customers and orders table look:

![image](https://user-images.githubusercontent.com/107522496/211578202-b4274c5a-e2c0-44a1-9efa-f0f20c192647.png)

![image](https://user-images.githubusercontent.com/107522496/211578274-e8cce9b9-ff94-4e00-9e09-bf5a03ac277d.png)

We have 5 rows in each table. 

---

![image](https://user-images.githubusercontent.com/107522496/211578421-64d1c130-9b80-4a8a-afe2-4c03e0720249.png)

Here is a _CROSS JOIN_. It's a combination of every single customer with every single order (5 x 5, which is why we have 25 rows returned). This is not useful. 
For example, even if a customer did not make an order, they still show up such as George Michael and Blue Steele.  

So, this doesn't tell us anything, but it is something we can do and it is technically a join. What we're going to see in the next video is how we can make joints that help us.

In other words, a _CROSS JOIN_ just takes every bit of information from both tables that we provided and cross multiplies them.

---

<!-- L 226 - Inner Joins --> 

# Inner Joins

So there are three main types of joints we're going to cover, ignoring _CROSS JOIN_ we briefly saw in the section above. We're going to see:

* INNER JOINS
* LEFT JOINS 
* RIGHT JOINS

---

![image](https://user-images.githubusercontent.com/107522496/211580517-8dcb5a28-2000-43c2-9033-772308d6a4ee.png)

Here, we have are two circles representing our two tables, and the middle is the overlap. The middle is the area we would target when using an INNER JOIN.  This is the most intuitive join.

---

![image](https://user-images.githubusercontent.com/107522496/211588772-2991e3fd-1748-4443-b4f5-9bbcf0975b7e.png)

This is the syntax  for an _INNER JOIN_

```sql
SELECT * FROM customers
JOIN orders
    ON customers.id = orders.customer_id;
```

`JOIN`: is a new word. We have to specify what table we're joining `customers` with. In this case, we are joining the customers table with the orders table.

`ON`: This is where we tell it how we want to join the tables. We want to join on where the customers(table) id(column is equal to the orders(table) customer_id column. 

In the above case, we are joining where the customer_id from the orders table EQUALS/MATCHES the id from the customer's table.

```diff
- REMEMEBER: the table which comes after FROM will be known as the LEFT table and the table which comes after JOIN will be the RIGHT table.
```

---

![image](https://user-images.githubusercontent.com/107522496/211592902-2cca8ede-6f7a-4257-a9ec-1f44915f5d0e.png)

```sql
SELECT * FROM customers
JOIN orders ON orders.customer_id = customers.id;
```

We have now joined both tables. Because we used `*`, we are retrieving all columns and rows from each table.

```diff
- Can also write INNER JOIN instead of just JOIN. Technically, the INNER here is implicit, but I can write it out if I wanted to explicitly use an INNER JOIN. It's just the default.

With LEFT and RIGHT JOIN, we have to specify LEFT and RIGHT.

```

---

![image](https://user-images.githubusercontent.com/107522496/211593320-b5823049-96af-41d9-aa86-8ce351ce9a5b.png)

The left side (the part which is highlighted in blue) is coming from the customers table and the left part (in white) is from the orders table. 

Now here's the most important part. the id from customers table and the customer_id from the orders table both match.  

So we are seeing who placed each order and what their email is and what their ID is alongside each order, date and order amount.

---

This is more information than we probably want. So, let's slim down the results ...

![image](https://user-images.githubusercontent.com/107522496/211595423-dd8202e6-f97c-4dbc-98d8-129489a7be03.png)

```sql
SELECT first_name, last_name, order_date, amount FROM customers
JOIN orders ON orders.customer_id = customers.id;
```

Now we can see better who made orders and for how much and when.

---

So, we started with customers table, and we joined it with the orders table. Now, let's see how it goes when going the other direction. 

![image](https://user-images.githubusercontent.com/107522496/211596410-92d23188-dbda-4f75-8439-b2607e9bc89a.png)

```sql
SELECT * FROM orders
JOIN customers ON customers.id = orders.customer_id;
```
Now we see the orders table first, on the left side and the customer table on the right (in white).

---

```diff
- The order of what goes after the ON does not matter. Can write `ON orders.customer_id = customers.id;` or `ON customers.id = orders.customer_id;`.
```

---

# Inner Joins with Group By

We can also combine _INNER JOIN_ with _GROUP BY_.

---

![image](https://user-images.githubusercontent.com/107522496/211601235-38a37946-0bec-496a-807e-899929589cc1.png)

Here, we have a list essentially of every order and the customer who made that particular order.

---

Now let's try and find the total amount that each customer spent? So I need to_ GROUP BY_ first name and last name for every unique customer and then we'll sum up the amounts.

So, from 

```sql
SELECT first_name, last_name, order_date, amount FROM customers
JOIN orders ON orders.customer_id = customers.id;
```

will change it to 

```sql
SELECT first_name, last_name, SUM(amount) FROM customers
JOIN orders ON orders.customer_id = customers.id
GROUP BY first_name, last_name;
```

We removed `order_date` because it's no longer in common between all the rows. We're grouping the rows by first name and last name now. 

![image](https://user-images.githubusercontent.com/107522496/211603739-9eef4074-1faa-4ec9-a341-1bc2ddc21cb5.png)

Now we can see the total amount each customer has spent. 

---

![image](https://user-images.githubusercontent.com/107522496/211604177-242e8a74-363e-4166-97bf-c18b48b6b996.png)

We can then also `ORDER BY` the `total` using an alias.

```sql
SELECT first_name, last_name, SUM(amount) AS Total FROM customers
JOIN orders ON orders.customer_id = customers.id
GROUP BY first_name, last_name
ORDER BY Total DESC;
```

---

This has been an example of doing a `GROUP BY` with a `JOIN` which is very common.

The `JOIN` just helps us get some information side by side, but it doesn't really tell us or give us answers or show us anything particularly useful until we then do some analysis. And a common way of analysing any of our data is using `GROUP BY` and then some aggregation function, such as MIN, MAX, AVG, finding the earliest or latest date etc.  

---

<!-- L 230: Left Join --> 

# Left Join

This is the second type of `JOIN`, the `LEFT JOIN`. Not as common as `INNER JOIN` but still helpful to know. Once you understand the left join, it makes understanding right joints very easy.

---


![image](https://user-images.githubusercontent.com/107522496/211608451-e36fb2c1-c138-447d-b76a-6b904acb73e3.png)

Here, we have two circles representing two tables.  If we have customers as our left table and orders as our right table, we are going to take every single row from the left side, every row from customers, and then if there's any corresponding order table data, it will also join that. But if not, we'll have a bunch of nulls.

```sql
SELECT first_name, last_name, order_date, amount FROM customers
LEFT JOIN orders ON orders.customer_id = customers.id;
```

This is how we would do a _LEFT JOIN_.

` ON orders.customer_id = customers.id;`: The thing I'm joining on in our table is not going to change here. We have one foreign key and we want to match it up with the `id` from the customers table.

```diff
- REMEMEBER: the table which comes after FROM will be known as the LEFT table and the table which comes after JOIN will be the RIGHT table.
```

---

![image](https://user-images.githubusercontent.com/107522496/211830424-495950ca-86a2-4708-ad57-02615f11b859.png)

```sql
SELECT first_name, last_name, order_date, amount FROM customers
LEFT JOIN orders ON orders.customer_id = customers.id;
```
This is a LEFT JOIN. If we did a INNER JOIN, it would look like:

![image](https://user-images.githubusercontent.com/107522496/211831291-64efd146-5a37-4456-8c6f-4e98df25cde1.png)

---

Remember, the difference is, in an _INNER JOIN_, we only get the overlap. In a _LEFT JOIN_, we take every single row from the left side. 

---

![image](https://user-images.githubusercontent.com/107522496/211831164-7cda5162-471e-48e0-b01b-646ddcfa3b5b.png)

So, in the above screenshot, this is our _LEFT JOIN_. Every customer is represented here. Boy George, George Michael, David Bowie, Blue Steel and Bette Davis.

Even though David and Blue don't have any orders, they are still displayed because in a LEFT JOIN we include everything in the left table. Because they have no values in the orders table, a `NULL` is displayed for them in the orders part of the joined table. 

---

![image](https://user-images.githubusercontent.com/107522496/211832388-37b305fc-e882-470b-8395-7941188771b1.png)

However, In a INNER JOIN, we won't see David and Blue because in an INNER JOIN, we only include rows which have data/overlap in both tables.   

---

# What is the Purpose of a left Join Compared to an Inner Join?

Sometimes this can reveal important information. If I wanted to know do we have any customers who have never placed an order and who are completely inactive? This would be one way to find that out. And then we could use a `GROUP BY` to organise the customers who have NULL for example. 

An _INNER JOIN_ is not going to help me. This only shows customers who have placed orders.

---

Another point: 

![image](https://user-images.githubusercontent.com/107522496/211835356-fb0481ca-3b76-465f-ab25-2f7695ccc1a2.png)

```sql
SELECT order_date, amount, first_name, last_name FROM orders
LEFT JOIN customers ON orders.customer_id = customers.id;
```

If we run this, we get the same results as an INNER JOIN:

![image](https://user-images.githubusercontent.com/107522496/211835556-d5e20051-1f11-48cf-8b8c-582a6397666a.png)

Just the order has been reversed. The reason why we get the same results is because:

![image](https://user-images.githubusercontent.com/107522496/211835816-c1c76eea-7e45-40dc-99da-6ecd39087681.png)

In the `orders` table, we have no orders which we don't have any orders that don't have a customer_id. Every order has a customer_id which means when we join with the right table, every order will have a customer attached to it as there's a complete overlap.

---

# Left Join With Group By and Using IFNULL

This is an example of a _LEFT JOIN_ with a _GROUP BY_ using a built in function we have not yet seen which is called `IF NULL`.

---

![image](https://user-images.githubusercontent.com/107522496/211839832-dfec9c96-32aa-420f-89e8-ee12b57bdafd.png)

Here, we will have the customers table on the left and then will join that with orders. This will show us, as we've already seen, which customers have not placed any orders along with all the customers who have placed orders. It will match them up with their corresponding orders.

![image](https://user-images.githubusercontent.com/107522496/211840041-c7e02004-8b81-4cce-8531-683a6dc58591.png)

The blue part is from the left table and contains every row from the customers table and is matched up with any overlap from the orders table (white section).
Where there is no overlap, that is where we get `NULL`.

---

Now we want to do now is group by first name and last name, and this will allow me to find out information, in aggregate, about our customers and the orders they've placed or have not placed.

---

![image](https://user-images.githubusercontent.com/107522496/211841403-d25c0fe1-0c89-4d09-b676-a30cb89d6803.png)

```sql
SELECT first_name, last_name, SUM(amount) AS total_spent FROM customers
LEFT JOIN orders ON customers.id = orders.customer_id
GROUP  BY first_name, last_name;
```

Have used `SUM` to total each customer's amount.

We already saw how to do this with an INNER JOIN. What's different now is that I have `NULL` values present.

---

Now, let's add something which will change `NULL` into `0`. We can do this using IF NULL

![image](https://user-images.githubusercontent.com/107522496/211843867-e3211bdf-dd87-4f90-b5f2-e6bb78fa2a1e.png)

`IFNULL` works by providing it something to evaluate. Everywhere that evaluation returns `NULL`, then we give it a second argument to replace the `NULL` with. 

---

![image](https://user-images.githubusercontent.com/107522496/211844029-f192c70b-e258-452c-97c7-b1919e5d92d2.png)

Now, `NULL` has been replaced with `0` and this now makes it easier to do things like do math with this sort.

---

<!- L234 - Right Join -->

# RIGHT JOIN

![image](https://user-images.githubusercontent.com/107522496/211844542-ba7a5bc9-14ae-4d18-8fd3-ff7e804971d2.png)

A is the left table and B is the right table. When we do a RIGHT JOIN, we will take all the rows from the right side and then include them, plus any overlap from the left side, meaning that we would also maybe have null values.


---

![image](https://user-images.githubusercontent.com/107522496/211848230-cca58b41-3fed-4221-ae3b-97c24ec3e03b.png)

This is an INNER JOIN.

---

![image](https://user-images.githubusercontent.com/107522496/211848393-6040a12d-3c6a-43b8-beb6-e668fe84221f.png)

This is a RIGHT JOIN. both, INNER JOIN and RIGHT JOINs are the same because very single order has a customer_id.

However, if we had a row in the orders table which did not have a customer_id, then it will look different to an INNER JOIN. 

---

![image](https://user-images.githubusercontent.com/107522496/211849218-faa7e338-c852-4a95-8899-570e207557a4.png)

At the moment, for `customer_id`, `NULL` is allowed but not a number which does not exist in the `customers` table. 

For example:

![image](https://user-images.githubusercontent.com/107522496/211849970-c3ed3c06-b29a-4736-bc0c-e82e17008563.png)

Now we have a row which has a `NULL` for `customer_id`. 

Now, in the real world, we would set this up so that you were required to have a `customer_id` because how can you just have an order with no `customer_id`? Who made the order in the real world? That doesn't really happen.

---

# Sidenote: CURDATE()

CURDATE() is a function which enters the current date.

---

![image](https://user-images.githubusercontent.com/107522496/211850682-cffe8df1-b17c-4940-8e74-98d4085e0e1f.png)

Now if we go back to our RIGHT JOIN, the right side are all orders, and the left side are customers. So that's an example of a RIGHT JOIN.
We take every row from orders the right side and then match up anything on the left where we can. And if we can't match it up, we just get `NULL`.

---

<!-- L 236: On Delete Cascade -->

# On Delete Cascade

This section looks at foreign keys and deletion.

![image](https://user-images.githubusercontent.com/107522496/211851539-127113a1-f579-4f10-ace2-82bf26901362.png)

In our example, we have two tables. The orders table has a customer_id column which is a foreign key which references `id` in the `customer` table.

---

But what is important to note is that we could have a customer without an order. That's totally valid. 

Now here's something to consider. What should happen when we delete a customer from our database? Let's say if we deleted Boy George. Boy George has 2 orders in the `orders` table.  What do we want to happen? There's different options. But first let's see what happens at the moment when we try to delete Boy George ...

![image](https://user-images.githubusercontent.com/107522496/211854269-3961e141-de6e-4e76-b226-7c0ca821c404.png)

This is the error we get.

Its saying by deleting this entry all of a sudden, the foreign key constraint fail because the foreign key constraint says that every `customer_id` inside of `orders` has to be a real `customer_id`, But if we suddenly delete this row, well, this is no longer a real valid `customer_id` that exists in the database.

---

So there are different options for how we handle this.

* One option is:  to update the `customer_id` upon deletion to be something like `NULL`, `unknown`, or `deleted`.
* Option two: to delete all of the orders placed by Boy George when we delete Boy George.

--- 

So, let's look at how we can automatically have any orders deleted when the corresponding customer who made the order is deleted.

The approach that we'll take is to add something to our schema called `ON DELETE CASCADE`.

> We could use ALTER TABLE to update table to include ON DELETE CASCADE, but in this case, will drop current tables and start from scratch.

---

# Sidenote

If we try to drop the `customers` table first, we will get an error:

![image](https://user-images.githubusercontent.com/107522496/211862064-2af233b9-0c2f-4c07-bf6f-8bddbfc27788.png)

This means, you have the orders table right now that has all these foreign keys that suddenly would be incorrect.

So, we will have to drop `orders` table first and then the `customers` table ... 

![image](https://user-images.githubusercontent.com/107522496/211863027-c48860ed-f71f-4c54-929e-4720fec8fc66.png)

---

![image](https://user-images.githubusercontent.com/107522496/211860070-acebc8ba-0e5e-4e15-bd51-ad4f84b1c687.png)

<!-- 3:09 -->

`FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE` means if the `customers` table `id` column is deleted, delete every row from orders that has `customer.id` as its `customer_id`.

--- 

![image](https://user-images.githubusercontent.com/107522496/211865602-1f4985d4-e183-40db-81d9-becc13b91cef.png)

Now I have created both tables again.

---

![image](https://user-images.githubusercontent.com/107522496/211865963-06f162ba-74b2-45f4-8598-dd2d0a19fbdb.png)

The first two orders are Boy George's, the ones where customer_id of 1.

---

![image](https://user-images.githubusercontent.com/107522496/211869427-dfa8fb4f-2535-4b0f-9cdd-ee24fd3016ff.png)

```sql
    DELETE FROM customers WHERE last_name = 'George';
```

Now I to delete `Boy George`. Previously I couldn't, because I would have had to delete the orders first, and then I could delete him as a customer. But now I don't have to do that. He has now been deleted.

---

![image](https://user-images.githubusercontent.com/107522496/211869883-b1461d35-b286-44ce-bb9c-4303171375fa.png)

No we can see that `Boy George` has been deleted. And now if we go and look at the `orders` table ...

![image](https://user-images.githubusercontent.com/107522496/211870057-f1112407-96fd-4e21-b151-167a35e5bee4.png)

We see that, the corresponding orders associated with `Boy George`, `customer_id` of 1, were deleted automatically.

---

![image](https://user-images.githubusercontent.com/107522496/211870534-60ebef3e-b578-4fa0-94e4-983f0a4e03a4.png)

And now if we delete `George Michael`, and then check the orders ...

![image](https://user-images.githubusercontent.com/107522496/211870671-ade50a25-748f-4887-b793-70bb4e617bdc.png)

We see his orders have also been deleted.

Automatically that deletion cascaded to any row that had that `customer_id` that was just removed. But we may not want to have that cascading behaviour. 

If it makes no sense to keep an order around after the corresponding customer is gone, we will delete those orders and we set that up using `ON DELETE CASCADE` when we create MySQL about the foreign key constraint.

---
<!-- L238: Joins Exercise -->  

# Joins Exercise

1. Start by creating the below schema

![image](https://user-images.githubusercontent.com/107522496/212019140-ea3ae841-0c61-4df8-921b-b57e36cacd1f.png)

`id` in the `students` table is a primary key and `student_id` in the `papers` table is a foreign key 

Answer to Step 1 and Step 2: 

![image](https://user-images.githubusercontent.com/107522496/212055536-f80c2626-e60d-46ac-a89c-35656c88d622.png)

---

2. Insert this data into the tables: 

```sql
INSERT INTO students (first_name) VALUES 
('Caleb'), ('Samantha'), ('Raj'), ('Carlos'), ('Lisa');

INSERT INTO papers (student_id, title, grade ) VALUES
(1, 'My First Book Report', 60),
(1, 'My Second Book Report', 75),
(2, 'Russian Lit Through The Ages', 94),
(2, 'De Montaigne and The Art of The Essay', 98),
(4, 'Borges and Magical Realism', 89);
```

`students` table:

![image](https://user-images.githubusercontent.com/107522496/212055682-1ee91e59-420b-4dd5-8283-844ccffda4be.png)

`papers` table: 

![image](https://user-images.githubusercontent.com/107522496/212055776-ffc48cf3-311f-46d5-8386-16d3f2b5153b.png)

---

3. Print this: 

![image](https://user-images.githubusercontent.com/107522496/212028934-d95c1301-e1b8-4475-9172-3add77d4b4ce.png)

Then join together the tables to get the above results. 

Answer: 

![image](https://user-images.githubusercontent.com/107522496/212056563-dbb96752-a9fa-427e-8ef6-1f83d6477ca1.png)

```sql
SELECT first_name, title, grade FROM students
INNER JOIN papers ON papers.student_id = students.id
ORDER BY grade DESC;
```

Can use `INNER JOIN` or `JOIN` as they both are the same thing.

---

4. Then print this:

![image](https://user-images.githubusercontent.com/107522496/212029683-9d672ad3-d08c-4f16-b334-6b7dd956334f.png)

In this one, we also have `NULL` values.

Answer: 

![image](https://user-images.githubusercontent.com/107522496/212059074-3186d875-e7da-4213-a390-029084d8d9c2.png)

```sql
SELECT first_name, title, grade FROM students
LEFT JOIN papers ON papers.student_id = students.id;
```

---

5. Then print this: 

![image](https://user-images.githubusercontent.com/107522496/212030003-548f77c5-2cda-4de4-9368-3d792434fe4c.png)

Now the `NULL` values become `MISSING` and where grades are `NULL`, they have become `0` . This means will have to use _IFNULL_.

Answer: 

![image](https://user-images.githubusercontent.com/107522496/212059665-e4e5018e-b973-44fc-a299-2f4f5068006e.png)

```sql
SELECT first_name, IFNULL(title, 'MISSING'), IFNULL(grade,0) FROM students
LEFT JOIN papers ON papers.student_id = students.id;
```

---

![image](https://user-images.githubusercontent.com/107522496/212030152-f4e119dd-35cf-4326-b5dc-a5b8a52a09c8.png)

Display the averages.

Answer: 

![image](https://user-images.githubusercontent.com/107522496/212065299-78469529-8a0b-4e3e-bf3f-f3ddcedca41f.png)

```sql
SELECT first_name, IFNULL(AVG(grade),0) AS average FROM students
LEFT JOIN papers ON papers.student_id = students.id
GROUP BY first_name
ORDER BY average DESC;
```

---

6. Then print this: 

![image](https://user-images.githubusercontent.com/107522496/212030298-64c26b05-47c4-4ea7-8c56-e92c1c8a7131.png)

Here, we are using a CASE statement. If average is above 75, then it is a passing 

Answer: 

![image](https://user-images.githubusercontent.com/107522496/212060807-57984a84-f71e-47ed-a17e-eb76815dd54c.png)

```sql
SELECT first_name, IFNULL(AVG(grade), 0) AS average,
    CASE
        WHEN IFNULL(AVG(grade), 0) >= 75 THEN 'passing'
        ELSE 'failing'
    END AS passing_status
FROM students
LEFT JOIN papers ON students.id = papers.student_id
GROUP BY first_name
ORDER BY average DESC;
```

---






















Continue from 238
